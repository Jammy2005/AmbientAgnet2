# # # # # #!/usr/bin/env python3
# # # # # """
# # # # # Minimal Gmail & Calendar OAuth setup.

# # # # # – Expects `credentials.json` (your downloaded OAuth client) in CWD  
# # # # # – Writes `token.json` next to it for reuse  
# # # # # – Grants Gmail send + Calendar scopes (change SCOPES as needed)
# # # # # """

# # # # # import os
# # # # # from google.oauth2.credentials import Credentials
# # # # # from google_auth_oauthlib.flow import InstalledAppFlow
# # # # # from google.auth.transport.requests import Request

# # # # # # adjust to whatever APIs you actually need
# # # # # SCOPES = [
# # # # #     "https://www.googleapis.com/auth/gmail.readonly",
# # # # #     "https://www.googleapis.com/auth/gmail.send",        # keep this if you still want to send
# # # # #     "https://www.googleapis.com/auth/calendar"
# # # # # ]

# # # # # def main():
# # # # #     creds = None
# # # # #     # load existing token
# # # # #     if os.path.exists("token.json"):
# # # # #         creds = Credentials.from_authorized_user_file("token.json", SCOPES)

# # # # #     # refresh or fetch new token
# # # # #     if not creds or not creds.valid:
# # # # #         if creds and creds.expired and creds.refresh_token:
# # # # #             creds.refresh(Request())
# # # # #         else:
# # # # #             flow = InstalledAppFlow.from_client_secrets_file("credentials.json", SCOPES)
# # # # #             creds = flow.run_local_server(port=0)
# # # # #         # save for next time
# # # # #         with open("token.json", "w") as f:
# # # # #             f.write(creds.to_json())
# # # # #         print("✅ token.json saved")
# # # # #     else:
# # # # #         print("✅ token.json is already valid")

# # # # # if __name__ == "__main__":
# # # # #     main()


# # # # # import os
# # # # # print(os.getenv("LANGGRAPH_API_KEY"))

# # # # from langgraph_sdk import get_client
# # # # import os
# # # # from dotenv import load_dotenv

# # # # load_dotenv()

# # # # client = get_client(
# # # #     url="https://ambientagent22-2fa840ef87fc5265af8d7d8f2e348260.us.langgraph.app",
# # # #     api_key=os.getenv("LANGSMITH_API_KEY")
# # # # )

# # # # import asyncio

# # # # async def test():
# # # #     try:
# # # #         result = await client.threads.list()
# # # #         print("✅ Connected! Threads:", result)
# # # #     except Exception as e:
# # # #         print("❌ Failed:", e)

# # # # asyncio.run(test())


# # # from langgraph_sdk import get_client
# # # import os
# # # from dotenv import load_dotenv
# # # import asyncio
# # # import uuid
# # # import hashlib

# # # load_dotenv()

# # # client = get_client(
# # #     url="https://ambientagent22-2fa840ef87fc5265af8d7d8f2e348260.us.langgraph.app",
# # #     api_key=os.getenv("LANGSMITH_API_KEY")
# # # )

# # # async def test():
# # #     try:
# # #         # generate a dummy consistent UUID thread id
# # #         raw_thread_id = "test-thread-123"
# # #         thread_id = str(uuid.UUID(hex=hashlib.md5(raw_thread_id.encode("UTF-8")).hexdigest()))

# # #         # create a thread (if it already exists, it should raise a conflict)
# # #         await client.threads.create(thread_id=thread_id)
# # #         print("✅ Thread created:", thread_id)

# # #         # update metadata to test write access
# # #         await client.threads.update(thread_id=thread_id, metadata={"debug": "true"})
# # #         print("✅ Thread updated!")

# # #     except Exception as e:
# # #         print("❌ Failed:", e)

# # # asyncio.run(test())


# # #!/usr/bin/env python3
# # """
# # preview_gmail_to_langgraph.py
# # --------------------------------
# # Fetch Gmail messages and print the JSON that *would* be sent to a LangGraph
# # email-assistant.  No network calls to LangGraph are made.

# # Requirements:
# #   pip install --upgrade google-api-python-client google-auth-httplib2 google-auth-oauthlib python-dotenv
# # """

# # import argparse
# # import base64
# # import hashlib
# # import json
# # import os
# # import sys
# # import uuid
# # from datetime import datetime, timedelta
# # from pathlib import Path
# # from typing import Dict, List, Optional

# # from google.oauth2.credentials import Credentials
# # from googleapiclient.discovery import build
# # from dotenv import load_dotenv

# # # -----------------------------------------------------------
# # # CONFIG
# # # -----------------------------------------------------------
# # SCOPES = ["https://www.googleapis.com/auth/calendar", "https://www.googleapis.com/auth/gmail.send","https://www.googleapis.com/auth/gmail.readonly"]
# # # Path to the OAuth token file generated by Google's flow
# # TOKEN_PATH = Path(__file__).with_name("token.json")
# # # -----------------------------------------------------------

# # load_dotenv(override=True)  # allow env vars in .env for flexibility


# # def load_gmail_credentials() -> Optional[Credentials]:
# #     """
# #     Load Gmail OAuth credentials from TOKEN_PATH *or* the env var GMAIL_TOKEN_JSON.
# #     Returns None on failure.
# #     """
# #     token_json = os.getenv("GMAIL_TOKEN_JSON")
# #     if token_json:
# #         try:
# #             token_data = json.loads(token_json)
# #             return Credentials.from_authorized_user_info(token_data, SCOPES)
# #         except Exception as e:
# #             print("Could not parse GMAIL_TOKEN_JSON:", e, file=sys.stderr)

# #     if TOKEN_PATH.exists():
# #         try:
# #             return Credentials.from_authorized_user_file(str(TOKEN_PATH), SCOPES)
# #         except Exception as e:
# #             print("Could not load token.json:", e, file=sys.stderr)

# #     print(
# #         "No valid Gmail credentials found. "
# #         "Run `google-oauthlib-tool` or your own OAuth flow to create token.json.",
# #         file=sys.stderr,
# #     )
# #     return None


# # def extract_message_part(payload: Dict) -> str:
# #     """Return the best-effort plain-text content of a Gmail message payload."""
# #     if payload.get("parts"):
# #         # Prefer text/plain
# #         for part in payload["parts"]:
# #             if part.get("mimeType") == "text/plain" and part.get("body", {}).get("data"):
# #                 return base64.urlsafe_b64decode(part["body"]["data"]).decode("utf-8", "ignore")
# #         # Fallback to text/html
# #         for part in payload["parts"]:
# #             if part.get("mimeType") == "text/html" and part.get("body", {}).get("data"):
# #                 return base64.urlsafe_b64decode(part["body"]["data"]).decode("utf-8", "ignore")
# #         # Recurse if nested multiparts
# #         for part in payload["parts"]:
# #             text = extract_message_part(part)
# #             if text:
# #                 return text
# #     # Not multipart
# #     if payload.get("body", {}).get("data"):
# #         return base64.urlsafe_b64decode(payload["body"]["data"]).decode("utf-8", "ignore")
# #     return ""


# # def extract_email_data(message: Dict) -> Dict:
# #     """Pull out the headers & body we care about."""
# #     headers = message["payload"]["headers"]
# #     header = lambda name: next((h["value"] for h in headers if h["name"] == name), f"Unknown {name}")

# #     return {
# #         "from_email": header("From"),
# #         "to_email": header("To"),
# #         "subject": header("Subject"),
# #         "page_content": extract_message_part(message["payload"]),
# #         "id": message["id"],
# #         "thread_id": message["threadId"],
# #         "send_time": header("Date"),
# #     }


# # def langgraph_payload(email: Dict) -> Dict:
# #     """Construct the JSON we would POST to LangGraph."""
# #     lg_thread_id = str(uuid.UUID(hex=hashlib.md5(email["thread_id"].encode()).hexdigest()))
# #     return {
# #         "langgraph_thread_id": lg_thread_id,
# #         "input": {
# #             "email_input": {
# #                 "author": email["from_email"],
# #                 "to": email["to_email"],
# #                 "subject": email["subject"],
# #                 "body": email["page_content"],
# #                 "id": email["id"],
# #                 "email_thread": email["thread_id"],
# #             }
# #         },
# #     }


# # def fetch_messages(
# #     service, address: str, minutes_since: int, include_read: bool
# # ) -> List[Dict]:
# #     """Query Gmail and return full message objects."""
# #     q = f"to:{address} OR from:{address}"
# #     if minutes_since > 0:
# #         after_ts = int((datetime.utcnow() - timedelta(minutes=minutes_since)).timestamp())
# #         q += f" after:{after_ts}"
# #     if not include_read:
# #         q += " is:unread"

# #     resp = service.users().messages().list(userId="me", q=q).execute()
# #     message_metas = resp.get("messages", [])
# #     if not message_metas:
# #         return []

# #     ids = [m["id"] for m in message_metas]
# #     full_messages = []
# #     for mid in ids:
# #         full = (
# #             service.users()
# #             .messages()
# #             .get(userId="me", id=mid, format="full")
# #             .execute()
# #         )
# #         full_messages.append(full)
# #     return full_messages


# # def main() -> None:
# #     parser = argparse.ArgumentParser(description="Preview LangGraph email payloads from Gmail.")
# #     parser.add_argument("--email", required=True, help="Email address to search (to: or from:)")
# #     parser.add_argument("--minutes-since", type=int, default=120, help="Only include messages newer than this")
# #     parser.add_argument("--include-read", action="store_true", help="Include already-read mail")
# #     args = parser.parse_args()

# #     creds = load_gmail_credentials()
# #     if not creds:
# #         sys.exit(1)

# #     service = build("gmail", "v1", credentials=creds, cache_discovery=False)
# #     messages = fetch_messages(service, args.email, args.minutes_since, args.include_read)

# #     if not messages:
# #         print("No messages found.")
# #         return

# #     print(f"Found {len(messages)} message(s). Printing LangGraph payload(s):\n")
# #     for i, msg in enumerate(messages, 1):
# #         email_data = extract_email_data(msg)
# #         payload = langgraph_payload(email_data)
# #         print(f"=== Email {i}/{len(messages)} ===")
# #         print(json.dumps(payload, indent=2, ensure_ascii=False))
# #         print()

# #     print("Done.")


# # if __name__ == "__main__":
# #     main()



# #!/usr/bin/env python3
# """
# preview_ingest.py
# Fetch Gmail messages, build the payload your LangGraph email-assistant expects,
# and print it.  ZERO network calls to LangGraph.
# """

# import argparse
# import base64
# import hashlib
# import json
# import os
# import sys
# import uuid
# from datetime import datetime, timedelta
# from pathlib import Path

# from google.oauth2.credentials import Credentials
# from googleapiclient.discovery import build

# # ─────────────────────────────────────────────────────────────────────────────
# # CONFIG  – use the *same* token path the working ingest script uses
# # ─────────────────────────────────────────────────────────────────────────────
# TOKEN_PATH = Path(
#     "/Users/ahmadjamshaid/Desktop/DPS-Agentic/ambient_agents/ambient_agents2/token.json"
# )
# SCOPES = ["https://www.googleapis.com/auth/gmail.readonly"]


# # ─────────────────────────────────────────────────────────────────────────────
# # AUTH  – identical to your run-ingest helper
# # ─────────────────────────────────────────────────────────────────────────────
# def load_gmail_credentials() -> Credentials | None:
#     if TOKEN_PATH.exists():
#         return Credentials.from_authorized_user_file(str(TOKEN_PATH), SCOPES)
#     print(f"[!] token.json not found at {TOKEN_PATH}")
#     return None


# # ─────────────────────────────────────────────────────────────────────────────
# # GMAIL HELPERS  – verbatim behaviour
# # ─────────────────────────────────────────────────────────────────────────────
# def extract_message_part(payload: dict) -> str:
#     if payload.get("parts"):
#         for part in payload["parts"]:
#             if part.get("mimeType") == "text/plain" and part["body"].get("data"):
#                 return base64.urlsafe_b64decode(part["body"]["data"]).decode("utf-8", "ignore")
#         for part in payload["parts"]:
#             if part.get("mimeType") == "text/html" and part["body"].get("data"):
#                 return base64.urlsafe_b64decode(part["body"]["data"]).decode("utf-8", "ignore")
#         for part in payload["parts"]:
#             txt = extract_message_part(part)
#             if txt:
#                 return txt
#     if payload.get("body", {}).get("data"):
#         return base64.urlsafe_b64decode(payload["body"]["data"]).decode("utf-8", "ignore")
#     return ""


# def extract_email_data(msg: dict) -> dict:
#     headers = msg["payload"]["headers"]
#     h = lambda name, default="": next((x["value"] for x in headers if x["name"] == name), default)

#     return {
#         "from_email": h("From"),
#         "to_email": h("To"),
#         "subject": h("Subject", "No Subject"),
#         "page_content": extract_message_part(msg["payload"]),
#         "id": msg["id"],
#         "thread_id": msg["threadId"],
#         "send_time": h("Date"),
#     }


# def build_langgraph_payload(email: dict) -> dict:
#     lg_thread_id = str(uuid.UUID(hex=hashlib.md5(email["thread_id"].encode()).hexdigest()))
#     return {
#         "langgraph_thread_id": lg_thread_id,
#         "input": {
#             "email_input": {
#                 "author": email["from_email"],
#                 "to": email["to_email"],
#                 "subject": email["subject"],
#                 "body": email["page_content"],
#                 "id": email["id"],
#                 "email_thread": email["thread_id"],
#             }
#         },
#     }


# # ─────────────────────────────────────────────────────────────────────────────
# # MAIN
# # ─────────────────────────────────────────────────────────────────────────────
# def main() -> None:
#     ap = argparse.ArgumentParser(description="Preview LangGraph email payloads.")
#     ap.add_argument("--email", required=True, help="Address to search for (to: or from:)")
#     ap.add_argument("--minutes-since", type=int, default=120, help="Only include newer messages")
#     ap.add_argument("--include-read", action="store_true", help="Also include read mail")
#     args = ap.parse_args()

#     creds = load_gmail_credentials()
#     if not creds:
#         sys.exit(1)

#     service = build("gmail", "v1", credentials=creds, cache_discovery=False)

#     q = f"to:{args.email} OR from:{args.email}"
#     if args.minutes_since > 0:
#         after = int((datetime.utcnow() - timedelta(minutes=args.minutes_since)).timestamp())
#         q += f" after:{after}"
#     if not args.include_read:
#         q += " is:unread"

#     resp = service.users().messages().list(userId="me", q=q).execute()
#     metas = resp.get("messages", [])
#     if not metas:
#         print("No messages found.")
#         return

#     print(f"Found {len(metas)} message(s):\n")
#     for i, meta in enumerate(metas, 1):
#         msg = (
#             service.users()
#             .messages()
#             .get(userId="me", id=meta["id"], format="full")
#             .execute()
#         )
#         email = extract_email_data(msg)
#         payload = build_langgraph_payload(email)
#         print(f"=== Email {i}/{len(metas)} ===")
#         print(json.dumps(payload, indent=2, ensure_ascii=False))
#         print()

#     print("Done.")


# if __name__ == "__main__":
#     main()


# save as gmail_oauth_helper.py
from google_auth_oauthlib.flow import InstalledAppFlow
import pathlib, json
from pathlib import Path


SCOPES = ["https://www.googleapis.com/auth/calendar", "https://www.googleapis.com/auth/gmail.send", "https://www.googleapis.com/auth/gmail.readonly"]

CLIENT_SECRETS = pathlib.Path("credentials.json")          # your OAuth client secret ↓
TOKEN_PATH    = pathlib.Path("ambient_agents2/token.json")

TOKEN_PATH = Path(
    "/Users/ahmadjamshaid/Desktop/DPS-Agentic/ambient_agents/ambient_agents2/token.json"
)

flow  = InstalledAppFlow.from_client_secrets_file(CLIENT_SECRETS, SCOPES)
creds = flow.run_local_server(port=0)
TOKEN_PATH.write_text(creds.to_json())
print("New token saved →", TOKEN_PATH)
